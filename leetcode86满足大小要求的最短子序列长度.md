**首先，计算出长度为i的从头开始的子数组的前缀和S[i]；**
这题我开始的想法是对于每个前缀和，从前缀和的当前位置向前数，直到找到满足要求的第一个位置并计算子数组长度
显然想法是可行的，但是时间复杂度是O(n2)级别的，运行最后一个测试用例的时候显示超时了。
后来看了别人的解法，发现还有一种很巧妙的思路如下：<br>
**1.如果我们能对于每个前缀和，按照索引顺序维持一个他前面的前缀和的递增数组，那么可以从从递增数组的头部开始遍历直到找到最近的一个满足要求的前缀和S[j1]**

**2.当找到一个符合要求的位置后，对于后面的前缀和S[k](k > i)，S[k]需要的满足要求的S[j2]一定在j1后面的数（不包括j1）形成的递增数组里面**
代码
```
int res = INT_MAX;
deque<int> Q;
for (int i = 0; i < Slen; i++)
{
    if (S[i] >= K) res = min(res, S[i]);
    while (!Q.empty() && S[Q.front()] + K <= S[i])
    {
        res = min(res, i-Q.front());
        Q.pop_front();
    }
    while (!Q.empty() && S[Q.back()] >= S[i]) S.pop_back();
    Q.push_back(i);
}
return res;
```
