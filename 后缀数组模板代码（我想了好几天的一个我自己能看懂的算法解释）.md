首先，求后缀数组网上都是用的倍增法，如https://blog.csdn.net/a1035719430/article/details/80217267
但是
### 网上的博客真的妈的都是狗屎！！！！！！！只讲了倍增法的概念但是从来不讲模板代码的思路。。。
我花了一天时间终于才搞清楚了模板代码的思路。。。
模板代码主要的技巧在于:
```
按照副位顺序更新主位的顺序（即SA）,按照SA来更新rank
```
以字符串"aaaaaaaa"为例
```
        1   2   3   4   5   6   7   8       a   a   a   a   a   a   a   a
sa[i]   1   2   3   4   5   6   7   8       a   a   a   a   a   a   a   a
第一轮 l = 0
p       1   2   3   4   5   6   7   8       
sa[i]   1   2   3   4   5   6   7   8       1   1   1   1   1   1   1   1
第二轮 l = 1
p       8   1   2   3   4   5   6   7       
sa[i]   8   1   2   3   4   5   6   7       2   2   2   2   2   2   2   1
第三轮 l = 2
p       7   8   6   1   2   3   4   5 
sa[i]   8   7   6   1   2   3   4   5       3   3   3   3   3   3   2   1
```
以字符串"aabaaaab"为例
```
                                            1   2   3   4   5   6   7   8
        1   2   3   4   5   6   7   8       a   a   b   a   a   a   a   b
sa[i]   1   2   3   4   5   6   7   8       a   a   b   a   a   a   a   b
第一轮 l = 0
p       1   2   3   4   5   6   7   8       
sa[i]   1   2   4   5   6   7   3   8       1   1   2   1   1   1   1   2
第二轮 l = 1
p       8   1   3   4   5   6   2   7       
sa[i]   1   4   5   6   2   7   8   3       1   2   4   1   1   1   2   3
第三轮 l = 2
p       7   8   2   3   4   5   6   1  
sa[i]   4   5   6   1   7   2   8   3       4   6   8   1   2   3   5   7
.............
```
假设字符串的长度为n,
利用倍增法构造数组的代码如下：
```
int sa[n+1] = {};
int rank[n+1] = {};
bool equal(int a, int b, int l)
{
    return rank[a] == rank[b] && rank[a+l] == rank[b+l];
}
void doubleing(string s) {
    int n = s.length();
    int p[n+1] = {};
    for (int i = 1 ; i <= n; i++)
    {
        sa[i] = i;
        rank[i] = s[i-1];
    }
    int l = 0;
    int sig = 128;
    int pos = 0;
    while (pos < n) {    
        for (int i = n - l + 1; i <= n; i++) p[++pos] = i;
        for (int i = 1; i <= n; i++)
        {
            if (sa[i] > l) p[++pos] = sa[i] - l;
        }
        int cnt[sig+1] = {};
        for (int i = 1; i <= n; i++) cnt[rank[i]]++;
        for (int i = 1; i <= sig; i++) cnt[i] += cnt[i-1];
        for (int i = n; i; i--) sa[ cnt[ rank[p[i]] ] -- ] = p[i];
        pos = 0;
        for (int i = 1; i <= n; i++) rank[sa[i]] = equal(sa[i], sa[i-1], l) ? pos : ++pos;
        sig = pos;
        l = !l? 1 : l<<1;
    }
}

```
得到rank[n+1]
翻译一下，假设字符串为"aabaaaab"
```
    1   2   3   4   5   6   7   8
    a   a   b   a   a   a   a   b
第一轮 
sa  1   2   4   5   6   7   3   8
    1   
    1   1
    1   1       1
    1   1       1   1
    1   1       1   1   1
    1   1       1   1   1   1
    1   1   2   1   1   1   1
    1   1   2   1   1   1   1   2
    
```
有几个难理解的地方在此记录下来：
```
1.为什么默认的sa[]是下标值？能不能乱填？
对于第1次循环，p[] = sa[],默认sa都是下标值算出来的第一次的sa，才都是下标值,rank[]才是正确的
对于第K次循环(K>= 1)如果算出的rank如果是正确的，可以证明第K+1次循环算出的rank[]必然也是正确的,证明如下：
对于sa[]，满足rank[sa[1]] <= rank[sa[2]] <= rank[sa[3]] <= rank[sa[4]] <= ...... <= rank[sa[n]];
对于产生的p[],p[]是按照副位排的序
如果rank[p[i]] < rank[p[j]]则新一轮rank[p[i]] < rank[p[j]]
如果rank[p[i]] == rank[p[j]] 且rank[p[i]+l] <= rank[p[j]+j]  
则新一轮的rank[p[i]] <= rank[p[j]]
以上两种情况p[i]均在p[j]前面
所以sa[]也是按照主位相同副位递增来排序，就有了
for (int i = n; i; i--) sa[ cnt[ rank[p[i]] ] -- ] = p[i];
这样得到的数组一定是非递减的。

2.为什么默认的rank[]是字符ascii码？
这个要从第一次循环来考虑，第一次循环l == 0,所以需要比较本身的大小，这时候就是按照ascii码比较的。
```
