首先，求后缀数组网上都是用的倍增法，如https://blog.csdn.net/a1035719430/article/details/80217267
但是
### 网上的博客真的妈的都是狗屎！！！！！！！只讲了倍增法的概念但是从来不讲模板代码的思路。。。
我花了一天时间终于才搞清楚了模板代码的思路。。。
模板代码主要的技巧在于:
```
按照副位顺序更新主位的顺序（即SA）,按照SA来更新rank
```
以字符串"aaaaaaaa"为例
```
        1   2   3   4   5   6   7   8       a   a   a   a   a   a   a   a
sa[i]   1   2   3   4   5   6   7   8       a   a   a   a   a   a   a   a
第一轮 l = 0
p       1   2   3   4   5   6   7   8       
sa[i]   1   2   3   4   5   6   7   8       1   1   1   1   1   1   1   1
第二轮 l = 1
p       8   1   2   3   4   5   6   7       
sa[i]   8   1   2   3   4   5   6   7       2   2   2   2   2   2   2   1
第三轮 l = 2
p       7   8   6   1   2   3   4   5 
sa[i]   8   7   6   1   2   3   4   5       3   3   3   3   3   3   2   1
```
以字符串"aabaaaab"为例
```
                                            1   2   3   4   5   6   7   8
        1   2   3   4   5   6   7   8       a   a   b   a   a   a   a   b
sa[i]   1   2   3   4   5   6   7   8       a   a   b   a   a   a   a   b
第一轮 l = 0
p       1   2   3   4   5   6   7   8       
sa[i]   1   2   4   5   6   7   3   8       1   1   2   1   1   1   1   2
第二轮 l = 1
p       8   1   3   4   5   6   2   7       
sa[i]   1   4   5   6   2   7   8   3       1   2   4   1   1   1   2   3
......................

```
假设字符串的长度为n,
利用倍增法构造数组的代码如下：
```
int sa[n+1] = {};
int rank[n+1] = {};
bool equal(int a, int b, int l)
{
    return rank[a] == rank[b] && rank[a+l] == rank[b+l];
}
void doubleing(string s) {
    int n = s.length();
    int p[n+1] = {};
    for (int i = 1 ; i <= n; i++)
    {
        sa[i] = i;
        rank[i] = s[i-1];
    }
    int l = 0;
    int sig = 128;
    int pos = 0;
    while (pos < n) {    
        for (int i = n - l + 1; i <= n; i++) p[++pos] = i;
        for (int i = 1; i <= n; i++)
        {
            if (sa[i] > l) p[++pos] = sa[i] - l;
        }
        int cnt[sig+1] = {};
        for (int i = 1; i <= n; i++) cnt[rank[i]]++;
        for (int i = 1; i <= sig; i++) cnt[i] += cnt[i-1];
        for (int i = n; i; i--) sa[ cnt[ rank[p[i]] ] -- ] = p[i];
        pos = 0;
        for (int i = 1; i <= n; i++) rank[sa[i]] = equal(sa[i], sa[i-1], l) ? pos : ++pos;
        sig = pos;
        l = !l? 1 : l<<1;
    }
}

```
得到rank[n+1]
翻译一下，假设字符串为"aabaaaab"
```
    1   2   3   4   5   6   7   8
    a   a   b   a   a   a   a   b
第一轮 
sa  1   2   4   5   6   7   3   8
    1   
    1   1
    1   1                   1
    1   1   2               1
    1   1   2   1           1
    1   1   2   1   1       1
    1   1   2   1   1   1   1
    1   1   2   1   1   1   1   2
    
```
