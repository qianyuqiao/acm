谈起floyd算法,一般我们会说这是一个动态规划算法.(怪不得如此优美)

为什么是个动态规划算法?因为它有递推公式:d[i][j]=min(d[i][j],d[i][k]+d[k][j])

还有一点就是三重循环,k要写外面,里面的i,j是对称的,随便嵌套没所谓.

这大概就是我们大部分人对floyd算法的了解.

那么,我们其实没有解决核心问题,为什么这样就能解决问题,为什么是这个递推公式,是这个嵌套顺序?

公式：
```
for (int k = 0; k < N; K++)
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
    {
        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);
    }
```

###这个算法像不像动态规划？但是这个本质上并不能用一般动态规划的思路来理解！！！！为什么呢，因为动态规划要求dp[i][k]和dp[k][j]都是最小的！
但是我们可以证明上面这段代码的正确性，
## 假设x是i和j之间最短路径经过的点中，索引值最大的一个点
## 虽然不能保证每一次dp[i][k]和dp[k][j]都是最小的，
## 但是能保证k 取到 x的时候，得到的结果dp[i][j]是最小的。
可以用数学归纳法证明
假设x1,x2是i, j最短路径中，i k 段的最大索引和k j 段的最大索引，很明显x1 < x, x2 < x;
根据结论，
### k == x1时，dp[i][k]为最小值
### k == x2时，dp[k][j]为最小值
所以当k == x时，dp[i][j] = min(dp[i][j] + )
